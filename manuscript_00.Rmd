---
title: 'Building the Million Transcriptome Ocular Meta-Atlas'
author:
  - Vinay Swamy:
      institute: bg
  - Temesgen Fufa:
      institute: mgog
  - Robert Hufnagel:
      institute: mgog
  - David McGaughey:
      institute:
        - bg
      correspondence: "yes"
      email: mcgaugheyd@mail.nih.gov
institute:
  - bg: Bioinformatics Group, Ophthalmic Genetics & Visual Function Branch, National Eye Institute, National Institutes of Health
  - mgog: Medical Genetics and Ophthalmic Genomics Unit, National Eye Institute, National Institutes of Health
    
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  word_document:
    reference_docx: word-styles-reference-01.docx
    fig_caption: yes
    pandoc_args:
      - '--lua-filter=scholarly-metadata.lua'
      - '--lua-filter=author-info-blocks.lua'
bibliography: references.bib
csl: investigative-ophthalmology-and-visual-science.csl
abstract: "The development of highly scalable single cell transcriptome technology has allowed for a high resolution view into huge numbers of single cell transcriptomes. Analyzing the transcriptomes between different projects is highly desirable as this would theoretically allow for better assessment of which effects are consistent across independent studies. However it is difficult to compare and contrast data across different projects as there are substantial batch effects from computational processing, single cell technology utilized, and the natural biological variation. While many single cell transcriptome specific batch correction methods purport to remove the technical noise it is difficult to ascertain which method works best. We developed an R package (scPOP) that can scan the results of multiple methods and key parameter choices and create a ranked list of the best performing method / parameter combinations. We use this package along with a Snakefile based workflow system to demonstrate how to optimally merge over one million cells from 30 datsets and three species to create a massive ocular single cell transcriptome meta-atlas. This provides a model how to efficiently create meta-atlases for tissues and cells of interest."
keywords: "RNA-seq, retina, RPE, ocular, eye, Snakemake, singlecell, scRNA, single-cell, singlecell, scPOP, R"
---

```{r Setup, message=FALSE, warning=FALSE, include=FALSE}
#knitr::opts_chunk$set(fig.pos = 'p') # Places figures on their own pages
knitr::opts_chunk$set(out.width = '100%', dpi=300)
library(tidyverse)
library(citr)
library(cowplot)
library(ggrepel)
library(colorspace)
library(flextable)
library(captioner)
library(pool)
library(RSQLite)
library(formattable)
library(ggalluvial)
library(scattermore)
library(grid)
library(ComplexHeatmap)
library(viridis)
library(Matrix)
library(matrixStats)
# setup caption-ing
fig_cap <- captioner("Figure")
supFig_cap <- captioner("Supplemental Figure")
tab_cap <- captioner("Table")
supTab_cap <- captioner("Supplemental Table")

scEiaD_2020_v01 <- dbPool(drv = SQLite(), dbname = "~/data/scEiaD/MOARTABLES__anthology_limmaFALSE___5000-transform-counts-universe-batch-scVIprojectionSO-8-0.2-500-0.6.sqlite", idleTimeout = 3600000)

meta_filter <- fst::read_fst('~/git/plaeApp/inst/app/www/meta_filter.fst') %>% as_tibble()
meta_filter <- meta_filter %>% mutate(CellType_predict = case_when(CellType_predict == 'Photoreceptor Precursors' ~ 'PR Precursors',
                                                                   CellType_predict == 'AC/HC_Precurs' ~ 'AC/HC Precursors',
                                                                   CellType_predict == 'RPC' ~ 'RPCs',
                                                                   CellType_predict == 'Mesenchymal/RPE/Endothelial' ~ 'Endothelial',
                                                                   TRUE ~ CellType_predict),
                                      UMAP_1 = UMAP_1 * 1,
                                      UMAP_2 = UMAP_2 * -1) %>%
  mutate(CellType_predict = case_when(!is.na(TabulaMurisCellType_predict) ~ 'Tabula Muris',
                                      TRUE ~ CellType_predict))


# meta data before doublet removal
load('~/data/scEiaD/n_features-5000__transform-counts__partition-universe__covariate-batch__method-scVIprojectionSO__dims-8__preFilter.scEiaDprojected__dist-0.2__neighbors-500.umap.Rdata')
umapRef <- umap

methods <- factor(c('scArches', 'bbknn','insct','magic', 'scVI','CCA', 'scanorama', 'harmony', 'fastMNN', 'combat', 'none'), levels = c('bbknn','CCA','combat','fastMNN','harmony','insct','magic','scanorama','scArches','scVI', 'none')) 

gse <- read_tsv('~/git/scEiaD/data/GEO_Study_Level_Metadata.tsv')

qc <- readr::read_tsv('~/data/scEiaD/QC.tsv.gz')

# cell type prediction
load('~/data/scEiaD/PREDICTIONSn_features-5000__transform-counts__partition-universe__covariate-batch__method-scVIprojectionSO__dims-8__preFilter.scEiaDprojected__dist-0.2__neighbors-500.Rdata')
test_predictions <- data.table::fread('~/data/scEiaD/981791_CTpredictortest_data_probabilities.csv.gz') %>% as_tibble %>% 
  mutate(max_pred_prob = rowMaxs(.[,-(33:36)] %>% as.matrix ), 
         pred_correct = ifelse(cell_type_id == true_cell_id, 'Correct', 'incorrect'))
# created by running 'source' on src/make_dotplot_markers.R
load('~/data/scEiaD/top_markers.Rdata')

# pmid search
load('~/data/scEiaD/top_marker_pmid.Rdata')
```


# Introduction
## Explosion of single cell transcriptomic atlases
The  recent introduction of lower cost and high throughput single cell sequencing technology has led to an explosion of research across many fields. As of November 2020, over 30 million cells have been sequenced across over 1,000 studies and the average size of each study is nearing 100,000 cells [@svenssonCuratedDatabaseReveals2020]. The retina was used as the source tissue in one of the earliest works in the high throughput single cell transcriptomics field and as of late 2020, over a dozen published studies containing over a million cells have used single cell technology to profile cell type specific gene expression patterns, cell fate trajectory, tissue and cell differentiation, and disease perturbation across multiple mammalian organisms [@buenaventuraIdentificationGenesEnriched2019; @clarkComprehensiveAnalysisRetinal2018; @collinCRXExpressionPluripotent2019; @collinDeconstructingRetinalOrganoids2019; @cowanCellTypesHuman2020; @diacouSix3Six6Are2018; @eldredThyroidHormoneSignaling2018; @hengHypoxiaToleranceNorrindeficient2019; @huDissectingTranscriptomeLandscape2019; @logiudiceSinglecellTranscriptionalLogic2019; @lukowskiSinglecellTranscriptomeAtlas2019; @luSingleCellAnalysisHuman2020; @macoskoHighlyParallelGenomewide2015; @menonSinglecellTranscriptomicAtlas2019; @okorenMicroglialFunctionDistinct2019; @pengMolecularClassificationComparative2019; @phillipsNovelApproachSingle2018; @rheaumeSingleCellTranscriptome2018; @ruedaHippoPathwayBlocks2019; @shekharComprehensiveClassificationRetinal2016; @sridharSingleCellTranscriptomicComparison2020; @tranSingleCellProfilesRetinal2019; @voigtMolecularCharacterizationFoveal2019; @voigtSinglecellTranscriptomicsHuman2019; @yanCellAtlasHuman2020]. 

<!-- ## Many researchers use processed count tables for methods development and hypothesis testing -->

While the gene - cell count tables are often made available in repositories like the Gene Expression Omnibus (GEO), there are no requirements to uniformly process the data. This means the count tables cannot be used in cross-study comparisons as even small differences in the computational pipeline (aligner, transcriptome reference, etc.) create study-specific effects. This issue can be addressed only by re-quantifying the data in a uniform environment. Fortunately, due to the continued development of computationally light-weight gene quantification tools into the single-cell space (e.g kallisto bustools, alevin), re-quantification does not require massive compute resources [@melstedModularEfficientPreprocessing2019; @srivastavaAlevinEfficientlyEstimates2019]. 

Even after re-quantification under identical conditions there remain study specific batch effects due to the variety in single cell technologies used and variation in tissue handling and processing across each scientific group. The single cell community has recognized that removal of these technical (also referred to as batch) effects is a critical issue and have independently developed many tools, though it remains unclear which tools and parameters are optimal for a particular dataset [@butlerIntegratingSinglecellTranscriptomic2018; @haghverdiBatchEffectsSinglecell2018; @hieEfficientIntegrationHeterogeneous2019; @johnsonAdjustingBatchEffects2007; @korsunskyFastSensitiveAccurate2019; @liuJointlyDefiningCell2020; @lopezDeepGenerativeModeling2018; @polanskiBBKNNFastBatch2020; @QueryReferenceSinglecell; @simonINSCTIntegratingMillions2020; @stuartComprehensiveIntegrationSingleCell2019; @vandijkRecoveringGeneInteractions2018]. 

<!-- Study specific web portals, should they exist, are silos which only contain the single cell transcriptomes related to their study. There are notable efforts to create web portals (UCSC Single Cell Browser, EBI Single Cell Expression Atlas) that allow for GUI-based viewing of data for most publicly available datasets. However, these again have the shortcoming as the study-specific web portals discussed above in that you still cannot directly compare between independent studies. In these situations it is impossible to compare directly across datasets. When exploring a gene expression pattern, it is crucial to have reproducibility across disparate groups to enhance confidence that effect is biological as bench experiments require large investments in time.  -->

<!-- ## Aggregation of results to create meta-atlas important -->

<!-- While these groups has leveraged this new technology to [do stuff], there is a large chasm to cross the enable outside groups to use the data in new ways. Several of these papers are accompanied by reactive web apps, which allow for relatively quick checks of gene expression across cell type or cluster assignment. However these web apps have minimal to no data exploration tools and are slow to operate, especially with the larger datasets.  -->

<!-- While lightly processed counts data is often provided, differences in both single cell technology (e.g. droplet or well based) and bioinformatic processing choices make it impossible to simply concatenate the datasets together as differences found will likely be technical.  -->

## The projectable meta-atlas

We propose that by re-processing publicly available raw single cell transcriptome data in a consistent bioinformatic framework and optimally using batch correction tools we can create a meta-atlas. As there are thousands of possible permutations of single cell tools, references, and parameter choices, we create our meta-atlas (which we refer to as the single cell Eye in a Disk or scEiaD) by benchmarking integration outcomes across multiple important single cell RNA-seq processing parameters (batch removal method, number of hyper-variable genes (HVGs), clustering resolution, etc.). The benchmarking system we developed uses a wide variety of metrics that we make easily available via the R package scPOP (single-cell Pick Optimal Parameters). The scEiaD will be of utility to two communities: the ocular community who can both search scEiaD for gene expression across many dimensions (e.g. cluster, cell type, study) and project their own single cell data onto scEiaD for comparison and rich automatic cell labelling. Also the computational community can use this very large, well-curated dataset to test algorithms for compute efficiency and performance in a diverse environment. As we believe data re-use is a powerful and efficient approach to facilitate discovery, we provide our meta-atlas code-base, the meta-atlas in several data formats, and propose general guidelines to optimally create custom meta-atlases.

# Results

## We identify `r meta_filter %>% pull(study_accession) %>% unique() %>% length() - 1` ocular scRNA datasets across 3 species

The first step in building a meta-atlas is identifying studies to draw the data from. We identified ocular single cell RNA sequencing (scRNA) studies by querying PubMed, the Sequence Read Archive (SRA), and the European Nucleotide Archive (ENA) for the inclusive terms "retina", "single cell", "scRNA", "ocular", "eye", "transcriptome." We then hand filtered the results to only keep ocular and normal (non-perturbed or mutagenized) data from single cell RNA-seq technology. On September 2020 we identified `r meta_filter %>% pull(study_accession) %>% unique() %>% length() - 1` deposited datasets that have been published in `r meta_filter %>% pull(Citation) %>% unique() %>% length()` publications (`r fig_cap(name = 'fig1', display = 'cite')`). In December 2020 we ran our search again, find N studies to project onto scEiaD. To provide a non-ocular reference we also downloaded the raw sequence data from the Tabula Muris project for re-processing. In cases where the fastq file from the SRA was not processed properly, we acquired the original bam files (SRA or personal correspondence) and re-extracted the fastq. After downloading all the data we had 5.7 TB across `r scEiaD_2020_v01 %>% tbl('metadata_filter') %>% pull(sample_accession) %>% unique() %>% length()` fastq file sets. 

```{r fig1, fig.width=13, fig.height=6, fig.cap=fig1_cap, echo=FALSE, message = FALSE}
fig1_cap <- fig_cap(name='fig1', caption =  'a. Counts of (study) accession, published papers, and batches for each scRNA technlogy, split by organism. b. Simplified directed workflow of major steps in scEiaD creation from raw counts to gene counts, benchmarking optimal integration methods (SnakePOP) to produce batch corrected latent dimensions (LatentDims), then downstream analysis outputs like clustering, differential gene testing (DiffTesting), and 2D UMAP visualization. c. Cell type counts extracted from published studies for the more common retina cell types, split by species. Count of study accessions for each species overlaid on bar plot.')

source('figs_and_tables/fig1.R')
plot_grid(plot_grid(a, c, align = 'v',  axis = 'lr', ncol = 1, labels = c('','c')), b,  nrow = 1, rel_widths = c(1.1,1), labels = c('a','b'))
```

## `r qc %>% nrow() %>% as.integer() %>% format(., big.mark=",", scientific=FALSE)` cells before quality control

Gene-level counts were quantified with the kallisto bustool pseudo-aligner for both the droplet and well based samples. After empty droplet removal, we had `r format(qc %>% nrow() %>% as.integer() , big.mark=",", scientific=FALSE)` cells. We then created a Seurat v3 object, calculated the percent mitochondrial genes counts, and removed cells which had more than 10% mitochondrial reads across all gene counts. For the droplet-based data, we also removed cells which had more than 3000 unique genes detected as these are likely to be doublets. After these standard quality control steps we were left with `r format(umapRef %>% nrow, big.mark = ",", scientific=FALSE)` cells. 

A core objective of many scRNA based studies is labeling the cell types. As this information is crucial to assess dataset integration and provide an accurate reference for user querying, we extracted individual cell labels with a combination of the GEO, supplemental information from the publication, web resources (e.g. a web app was created for the paper), and personal correspondence. After normalizing cell type name nomenclature, we obtained labels for `r meta_filter$CellType %>% table() %>% sum()` cells across `r meta_filter$CellType %>% table() %>% length()` cell types (`r supTab_cap(name = 'supTab1_CTcounts', display = 'cite')`). 

## Running `r methods %>% length()` tools in a Snakefile-based system

Disentangling the technical and biological effects from the datasets is crucial. A wide variety of methods have been written for this function. As we were uncertain which would perform the best and it is difficult to manually assess performance we ran `r methods %>% length()` tools with a commonly used set of key parameters: 2000 hyper variable genes, 8 and 30 latent dimensions returned, and the louvain clustering algorithm with 7 k-nearest neighbors. The Snakemake system was used to automate the running of the wide variety of tools. In total 15,226 jobs were run to quantify expression and assess integration performance. 

The two key metrics which have to be balanced in order to optimize performance are batch mixing (the same cell types should be similar across independent studies) and cell type or cluster purity (where different cell types or clusters should be distinct). While these can be visually assessed by looking at marker gene expression across the 2D UMAP projection, it is more rigorous and scalable to quantify these diametrically opposed characteristics.

We define batch as being each biological sample and assume each study is at least one unique sample. We studied the metadata and methods of each study to determine if the particular study contained multiple unique biological samples. In the end we identified `r umapRef %>% pull(batch) %>% unique() %>% length()` batches across `r umapRef %>% pull(study_accession) %>% unique() %>% length()` deposited datasets in `r umapRef %>% left_join(gse) %>% pull(PMID) %>% unique() %>% length()` published papers.

## scPOP wraps several different methods at measuring integration performance. 

scPOP is a lightweight, low dependency R package which brings together the Local Simpson Index (LISI) and Average Silhouette Width (ASW) metrics from Harmony and kBET, respectively, and brings in the Adjusted Rand Index (ARI) and Normalized Mutual Information (NMI) algorithms from aricode. The LISI and ASW were used to measure batch mixing (where lower is better), cell type mixing (higher is better), and cluster mixing (higher is better). NMI and ARI were used to assess the consistency of cell type to cluster assignment (where 1 is perfect correspondence between cluster and cell type).

To visualize the interplay between batch mixing and cell type distinction we plot the batch mixing LISI score (which has been multiplied by -1) on plotted on the y-axis (higher is better) against the cluster LISI on the x-axis (higher is better). The best performer on both metrics will be in the top right corner  (`r supFig_cap(name = 'supFig_benchmark', display = 'cite')`a). In the same manner we plot the silhouette metric (`r supFig_cap(name = 'supFig_benchmark', display = 'cite')` b). 

<!-- ## scPOP reveals different priorities across the different batch integration methods -->

On one extreme we have combat, which merges together different batches very well, but also mixes together the distinct cell types (`r fig_cap(name = 'figBenchmark', display = 'cite')`a). The other extreme is not using any batch integration method, where you see very distinct groups of cells, but also each nearly study is has a distinct space in the 2D (`r fig_cap(name = 'figBenchmark', display = 'cite')`b). In our scEiaD dataset we see that like combat, Harmony and CCA are weighed more towards batch mixing then cluster and cell type purity. Scanorama, fastMNN, and bbknn more prioritize cleanly separating the clusters. With our scEiaD meta-atlas insct, scArches, and magic do not perform particularly well in batch mixing or cluster purity. 

## Different normalization methods alter integration performance

<!-- https://www.frontiersin.org/articles/10.3389/fgene.2020.00041/full -->
There are several normalization approaches that have been used or published. The "standard" approach that the popular analysis packages Seurat and anndata use by default is to, per cell, divide the counts by the sum counts for the cell, multiply by a scaling factor, then log transform. This helps make the count distribution more normal, which is an assumption that many algorithms require. In contrast, the scran normalization method groups cells into pools and normalizes across the pool summed counts instead of the individual cell counts. We also use the square root (sqrt) normalization which replaces the log transformation with a square root. Library size (libSize) normalization omits the sqrt or log transformation. Finally some methods like scVI directly use the raw counts data for modeling the data. 

To merge the different scores we define $sumZScale = \sum scale(m)$ where m is a metric (LISI by batch, LISI by cluster, LISI by cell type, silhouette by batch, silhouette by cluster, silhouette by celltype, NMI, and ARI). In this scaled metric that weights the different benchmarking algorithms evently, scVI performs best. As expected the libSize normalization which omits the log or square root scaling generally performs the worst (`r fig_cap(name = 'figBenchmark', display = 'cite')`c). We see that the remaining normalization approaches alters the batch correction performance, though the exact outcome differs across the different methods. We also see that changing the number of latent dimensions (8 or 30) can occasionally dramatically change performance. These results demonstrate the importance of assessing performance in a rigorous manner aceoss many parameters. 

<!-- For users who have custom needs, the weights of each metrics can be customized in scPOP to prioritize batch mixing or cluster/cell type separation. -->

```{r figBenchmark, fig.width=14, fig.height=8, fig.cap=figBenchmark_cap, echo=FALSE, message = FALSE}
figBenchmark_cap <- fig_cap(name='figBenchmark', caption =  'a. Example of a method (combat) which has a high level of batch blending, but poor separation of cell types (colored by cell type). b. no batch correction cleanly separates cell types but does not mix batches (colored by study). c. sumZScale (higher is better) for each method across a variety of data normalizations. All methods shown here use 2000 HVG, louvain clustering, and 8 latent dimensions d. Optimal parameters for scVI methods across 1000 to 10000 HVGs and 4 to 100 latent dimensions.')

source('figs_and_tables/fig_umap_benchmarking.R')
plot_grid(
  plot_grid(
    umap_plot_maker(umapCombat), 
    umap_plot_maker(umapNone, color_against = 'study_accession'),
    rel_widths = c(1.3, 1),
    labels = c('a','b')), 
  plot_grid(
    zscore_sum_all_methods, 
    zscore_droplet_scVI_optimize,
    labels = c('c','d')),
  nrow = 2,
  rel_heights = c(1, 0.4)
)
```

<!-- ## scVI has highest integration performance -->

<!-- scPOP finds that for our dataset scVI has the strongest performance, with a sum score of SOMETHING. The next highest performers are fastMNN, harmony, and scanorama. We do not claim that these results are general - rather we emphasize that for each (meta) atlas creation that scPOP or some similar unbiased approach where a range of several key parameters (e.g. HVG number) are tested in a quantitative framework.  -->

## Further optimization of scVI with grid search and projection

To find the best set of parameters for the creation of scEiaD we did a grid search across key parameters: hyper variable genes (HVG), latent dimensions, and k nearest neighbors. Furthermore we used a recent advance in scVI capability adapted from scArches that allows one to build a reference model and project the new cells onto it. We built a human-only scVI model and then projected the mouse and macaque data onto it. We then compared the "scVIprojected" against the against the straight scVI across all the previously mentioned parameters. Using scPOP we first saw that the scVIprojection approach generally performed better than running scVI with all of the data. We found the optimal parameters to be 5000 HVG, 10 latent dimensions, and a resolution of 0.6 with the leiden algorithm implemented by PARC (`r fig_cap(name = 'figBenchmark', display = 'cite')`d). We also varied the UMAP projection values of nearest neighbors and minimum distance to qualitatively pick a 2D projection, selecting a minimum distance of 0.1 and 500 nearest neighbors. 

## High accuracy xgboost ML model built to label unknown cell types

To further study cell type specific expression patterning we needed to label the `r format(umapRef %>% nrow() - meta_filter %>% filter(!is.na(CellType)) %>% nrow(), big.mark=",", scientific=FALSE)` unlabeled cells. Traditionally this is done by clustering the cells, then using cell type specific markers to label the clusters. However, as we had hundreds of thousands of expert labelled cells across `r umapRef %>% filter(!is.na(CellType)) %>% left_join(gse) %>% pull(PMID) %>% unique() %>% length()` studies (`r fig_cap(name = 'fig1', display = 'cite')`a) we built a xgboost-based machine learning model that used half of the labeled cells as a training set (see methods for more details) to train a cell type predictor for scEiaD input. The trained model was used to predict the cell type assignments for all cells in scEiaD. In this manner we both label most cells (cells which cannot be assigned a cell type assignment with a confidence above 0.5 were left unlabeled) and correct a small number of probable mislabels in the truth set (`r fig_cap(name = 'figXGboost_umap', display = 'cite')`a). 

<!-- ## ML cell type predictor has high accuracy across most cell types -->

The precision recall (PR) curve visualizes the ability of the model to precisely label known cells at a given confidence. The area under the PR curve (AUC) summarizes the effectiveness of the model across different cell types, with 1 being the highest performance. The xgboost model can predict rods, bipolar cells, and Muller glia with near perfect performance (`r fig_cap(name = 'supFig_PR', display = 'cite')`). Most of the remaining cell types can be predicted with an AUC of well over 0.9. The cell types that were the most challenging for the model to predict were the artery, choriocapillaris, and vein. Artery, choriocapillaris, and vein are constructed from endothelial cells and we find that for all three of these, endothelial was the second most common label. The ML model also performs under 0.9 for predicting the neurogenic cell type label; however the most next common label that is predicts are the highly related retinal progenitor populations (RPCs) (`r supTab_cap(name = 'supTab_CTmislabels', display = 'cite')`). Overall, our xgboost based ML model shows strong accuracy across the major cell types of the retina. 

<!-- ## Certain retina cell types have more stable community consensus IDs -->

<!-- With the wide diversity of the scEiaD we can get a sense on how consistent the retina community is at labelling the major cell types of the retina. By calculating the AUC against each individual cell type and study, we can see which cell types are consistently labeled correctly across most (`r fig_cap(name = 'supFig_PR_cap', display = 'cite')`). Most studies show very similar performance with our ML model. The study with the lowest correspondence between published and predicted label is Macoksko et al; this study is notable as it was the first demonstration of the droplet based scRNA technique.   -->

```{r figXGboost_umap, fig.width=18, fig.height=13, fig.cap=figXGboost_umap_cap, echo=FALSE, message = FALSE}
figXGboost_umap_cap <- fig_cap(name='figXGboost_umap', caption =  'filler text hello world')

source('figs_and_tables/sup_fig2__celltype_xgboost_labelling.R')
source('figs_and_tables/make_meta_scatter_umap_plot.R')
source('figs_and_tables/dotplot.R')

# markers for dotplot
input <- list()
input[['dotplot_Gene']] <- top_markers %>%  
  filter(grepl('Amacrine|Rod|Cone|Retinal|Muller|Horizon|Bipol|Astro|RPE|Micro', cluster), D_KL > 0.2) %>%  
  group_by(cluster)  %>% 
  slice_max(mean_auc, n =5) %>% 
  pull(Gene)
input[['dotplot_groups']] <- c('CellType_predict')
input[['dotplot_filter_cat']] <- 'CellType_predict'
input[['dotplot_filter_on']] <- (meta_filter %>%
                                   filter(grepl('Amacrine|Rod|Cone|Retinal|Muller|Horizon|Bipol|Astro|RPE|Micro', CellType_predict)) %>% 
                                   pull(CellType_predict) %>% unique())
d <- make_dotplot(input, scEiaD_2020_v01, meta_filter, cat_to_color_df)
dplot <- d  + facet_grid(vars(cluster), scale = 'free_y', space = 'free') + theme(
  strip.background = element_blank(),
  strip.text.y = element_blank()
)


input <- list()
input[['meta_column']] <- 'CellType_predict'
input[['pt_size_back']] <- 0
input[['pt_size_meta']] <- 0
#input[['gene_and_meta_scatter_tech']] <- 'Droplet'
input[['meta_column_transform']] <- 'None'
input[['label_toggle']] <- 2
input[['meta_filter_cat']] <- 'CellType_predict'
input[['meta_filter_on']] <- NULL
ctp <- make_meta_scatter_umap_plot(input, mf, meta_filter,
                                   celltype_predict_labels,
                                   celltype_labels,
                                   tabulamuris_predict_labels,
                                   cluster_labels,
                                   cat_to_color_df
)

input <- list()
input[['meta_column']] <- 'CellType_predict'
input[['pt_size_back']] <- 1
input[['pt_size_meta']] <- 1
input[['gene_and_meta_scatter_tech']] <- 'Droplet'
input[['meta_column_transform']] <- 'None'
input[['meta_filter_cat']] <- 'CellType_predict'
input[['meta_filter_on']] <- c('AC/HC Precursors','Amacrine Cells','Astrocytes','Bipolar Cells','Cones','Early RPCs','Endothelial','Horizontal Cells','Late RPCs','Microglia','Muller Glia','Neurogenic Cells','Pericytes','PR Precursors','Red Blood Cells','Retinal Ganglion Cells','Rod Bipolar Cells','Rods','RPCs','RPE','Schwann','Tabula Muris')
ctp2 <- make_meta_scatter_umap_plot(input, mf, meta_filter,
                                    celltype_predict_labels,
                                    celltype_labels,
                                    tabulamuris_predict_labels,
                                    cluster_labels,
                                    cat_to_color_df
)

input <- list()
input[['meta_column']] <- 'CellType_predict'
input[['pt_size_back']] <- 0
input[['pt_size_meta']] <- 0
#input[['gene_and_meta_scatter_tech']] <- 'Droplet'
input[['meta_column_transform']] <- 'None'
input[['meta_filter_cat']] <- 'CellType_predict'
input[['meta_filter_on']] <- NULL
org <- make_meta_scatter_umap_plot(input, mf, meta_filter,
                                   celltype_predict_labels,
                                   celltype_labels,
                                   tabulamuris_predict_labels,
                                   cluster_labels,
                                   cat_to_color_df
)

plot_grid(dplot + theme(legend.title = element_text(angle = 90),
                        axis.text = element_text(size = 6)),
          plot_grid(ctp$plot + theme(legend.position = "none"), 
                    ctp2$plot + theme(legend.position = "none") + facet_wrap(~CellType_predict),
                    grid.grabExpr(draw(ct_confusion)),
                    org$plot + facet_wrap(~organism) + theme(legend.position = "none"), 
                    ncol = 2,
                    labels = c('b', 'c', 'd', 'e'),
                    rel_heights = c(1,0.8)), 
          ncol = 2, 
          rel_widths = c(1,3), 
          labels = c('a',NULL)) 

```

## ML cell type labels result in high study diversity for each cell type

After ML projection of cell type labels from the original `r meta_filter %>% filter(!is.na(CellType)) %>% nrow()` labels onto a total of `r meta_filter %>% filter(!is.na(CellType_predict) | !is.na(TabulaMurisCellType_predict)) %>% nrow()` cells we have substantially improved the number of studies per cell type. For example, we went from `r joinedSA %>% filter(CellType == 'Muller Glia') %>% pull(2)` human studies with labelled Muller Glia to `r joinedSA %>% filter(CellType == 'Muller Glia') %>% pull(5)` after labelling (`r supTab_cap(name = 'supTab_SAcounts', display = 'cite')`). Overall we go from an average of `r joinedSA %>% filter(CellType != 'Unlabelled') %>% pull(2) %>% mean()` studies per human cell type to `r joinedSA %>% filter(CellType != 'Unlabelled') %>% pull(5) %>% mean()` and `r joinedSA %>% filter(CellType != 'Unlabelled') %>% pull(4) %>% mean()` studies per mouse cell type to `r joinedSA %>% filter(CellType != 'Unlabelled') %>% pull(7) %>% mean()` after transferring the cell type labels. 

As another check on the quality of the cell type assignments, we ran pairwise differential expression tests between the predicted cell types (see methods for further details). We show the five most consistently differentially expressed genes for each of the major retina cell types (`r supFig_cap(name = 'figXGboost_umap', display = 'cite')`a). As a simple metric to identify known and unknown genes relating to the cell type specific expression we search PubMed for the number of publications with two searches per gene. The first search is the more precise "gene AND cell type" (e.g. "PDE6H AND Cones") and the second search is the more inclusive "gene AND retina" (e.g. "PDE6G AND Retina"). Of the 55 genes in (`r supFig_cap(name = 'figXGboost_umap', display = 'cite')`a), 40 had one or more citations in the gene/celltype search (table X) and 51 had one or more citation in the inclusive search. The 55 genes had a mean of `r top_markers %>% group_by(cluster)  %>% slice_max(mean_auc, n =5) %>% pull(c2) %>% mean() %>% round()` studies (with the inclusive gene by "retina" search). In contrast, 100 randomly chosen genes had a mean of `r pmid3 %>% map(function(x) sum(!is.na(x))) %>% unlist() %>% enframe() %>% pull(value) %>% mean() %>% round`. 

The four genes with zero hits were SCRG1 (Astrocytes), BTBD8 (Bipolar Cells), GATM (Microglia), and FRZB (Muller Glia). In a more exhaustive literature search we find that SCRG1 is a secreted protein which marks brain neurons, regulates human mesenchymal stem cells differentiation, and is overexpressed in brain astrocyte precursors [@aomatsuNovelSCRG1BST12014; @chaboubTemporalProfilingAstrocyte2016]. BTBD8 contains BTB/POZ domains known to generally be associated with with transcription factor mediated protein-protein interactions [@xuMolecularCloningCharacterization2004; @zollmanBTBDomainFound1994]. GATM is mitochondrial enzyme involved in creatine biosynthesis and was previously shown to up-regulated in a brain microglia population [@hammondSingleCellRNASequencing2019]. FRZB was previously referred to as SFRP3 and this Wnt pathway member has been previously shown to be active in Muller Glia [@zhuCharacterizationCanonicalWnt2018]. Overall, we find very high concordance with known retina cell type markers.

## The scVI-based scEiaD UMAP projection blends batches while separating cell types

The 2D UMAP projection of the scVI-calculated batch corrected 8 latent dimensional space blends the `r meta_filter %>% pull(study_accession) %>% unique() %>% length() - 1` studies together while also maintaining distinct space for the `r meta_filter$CellType_predict %>% table() %>% length()` unique cell types. We also see good mixing across all the droplet and well based single cell technologies (`r supFig_cap(name = 'supFig_platformInt', display = 'cite')`). We see the neurogenic and progenitor populations from which the retinal cell types are derived near the center of the UMAP visualization. The photoreceptor precursors are adjacent to the neurogenic population and flow into the rods and cones. The amacrine and horizontal precursors (AC/HC) likewise flow from the neurogenic center into the mature amacrine and horizontal cells. 

The photoreceptors (cones and rods) of the retina which are responsible for color and low-light vision, respectively, are near each other in the UMAP space. The major remaining retina cell types, by proportion in the mammalian eye are the Muller Glia, which are a glial cell type which help support the neurons of the retina. Next we have the neural cell types which transmit and help interpret the signals from the photoreceptors before they leave the retina via the optic stalk: the amacrine cells, retinal ganglia, horizontal, and bipolar cells. All of these cells are in well defined spaces in the UMAP. Finally we see even across species that the major cell types still group near each other (`r supFig_cap(name = 'figXGboost_umap', display = 'cite')`d). The macaque retina cells are not present in the precursor/neurogenic center of the UMAP as expected because only fully developed tissues were sampled in these data.  

<!-- ## Pseudobulk testing leverages high biological diversity to provide robust differential expression results -->

<!-- Differential gene expression testing between clusters or cell types in the single cell field usually involve using running the statistical test of choice with all individual cells across the group. In bulk RNA-seq the tests are done in relation to replicates, which are generally required. As we have a large number of replicates, we can sum our gene expression counts by group (e.g. celltype or cluster, split by organism and study). After this summing, we now have created a "pseudo-bulk" matrix. The statistical properties (CITE SOMETHING) are now similar to the traditional bulk RNA-seq experiment, allowing us to leverage the robust tooling. We use the edgeR test to run our differential expression tests.  -->


## Projection of new data onto scEiaD demonstrates how iPSC-based cells are similar to tissue-based cells

The hard work of creating this resource can be leveraged and extended by the wider community with a few relatively simple steps and modest compute requirements. Very briefly, if outside groups quantify their mouse or human scRNA with kallisto and the same references (see methods), they can overlay their data on top of scEiaD by 1. installing scVI >=0.8.1, 2. downloading our 13 megabyte scVI model, and 3. following the Jupyter notebook on Google colab that we provide as supplemental file BLOOP and as a live demo at http://colab.google. We demonstrate the power of this approach in two ways.

First, we project another retina dataset onto scEiaD from Fadl et al. As this is a pan-retina tissue sample, we would expect most of the major cell types of the retina to be present. In the Google colab notebook we show how a set of the reads from SRR12130660 can be processed from the raw reads to a UMAP visualization overlapping our scEiaD in under 15 minutes. Indeed, as expected we see many amacrine, rods, muller glia, bipolar, a few cones and retinal ganglion, and a small number of non-retina cells (`r supFig_cap(name = 'projection_fig', display = 'cite')`b). 

Second, we demonstrate how the RPE derived from the Bharti iPSC differentiation method closely match tissue RPE from other studies (the largest being the Cowan et al data; `r supFig_cap(name = 'projection_fig', display = 'cite')`a). Cells generated with this process have been extensively validated with functional RPE tests. Our scRNA approach provides another layer of evidence that the Bharti iPSC-RPE differentation protocol generates RPE cells that are functionally equivalent to human adult RPE in an unbiased manner. 

# Methods

## Reproduciblity

The set of Snakemake pipelines that takes in the raw fastq sequence and outputs the scEiaD is at https://github.com/davemcg/scEiad [@kosterSnakemakeScalableBioinformatics2012]. The publication commit is BLOOP. Furthermore, the repository has been deposited at Zenodo under BLOOP. We will briefly discuss the pipeline choices, programs and algorithms, and versions below. For the R packages, we provide package versions as the supplementary file "R_session_info.txt"

## Quantification of gene counts

Gene quantification is handled by the SnakQUANT snakefile. Kallisto (0.46.2) was the pseudoaligner [@brayNearoptimalProbabilisticRNAseq2016]. The reference transcriptomes used to build the kallisto index were the Gencode "gencode.vM25.annotation.gtf.gz" and "gencode.v35.annotation.gtf.gz" for mouse and human, respectively [@harrowGENCODEReferenceHuman2012; @jGENCODEReferenceHuman2012]. The Ensembl release 101 "Macaca_mulatta.Mmul_101.gtf.gz" was used for the macaque transcriptome [@yatesEnsembl20202020]. For the relatively few single ended samples, the params "--single -l 200 -s 30" were used for kallisto quant. Otherwise the "--bias" flag was added. For the droplet-based samples, bustools (0.39.4) was used to extract the single cell barcodes, sort the output, and fix barcoding errors [@melstedBarcodeUMISet2019].  

## Intersection of gene names between mouse, macaque, and human

To facilitate comparison of gene expression across species, where possible we converted mouse and macaque gene ids and names to human ones. We downloaded a mapping of orthologous genes between human, mouse, and macaque using the Ensembl BioMart web browser in November 2020. We identified 15XXX human genes that could be directly mapped to mouse and macaque orthologs. Genes present in mouse or macaque that were not found in human were not used for scVI batch correction, but were retaomed and used for differential gene expression. 

## Custom macaque reference quantification

As we noticed that several retina marker genes (e.g. NRL and CRX) had very low expression in the macaque data we quantified the scRNA data twice: once with the Ensembl reference and again with the same Gencode human reference used for the human data. We compared the gene-level counts for each cell and replaced the macaque gene count with the human counts if the human counts were greater than the macaque counts and, to prevent genes with very few total counts from being used, we required the counts greater than the first quartile of non-zero macaque gene expression.

## Remove empty droplets and further QC.

After bustools count, we used R (3.6.2) to remove empty droplets. The BUSpaRse package was used to input the bustools counts mtx file. The DropletUtils package with the "barcodeRanks" function was used to automatically detect the inflection point in the barcode count ranks that delineates the likely empty droplets [@lunEmptyDropsDistinguishingCells2019]. We then removed cells with percent mitochondrial reads of >10%. After merging the individual count matrices into one sparse matrix, we created a Seurat version 3 object and removed cells with fewer than 200 detected unique genes, and for the droplet data, more than 3000 detected genes (these are likely to be doublets) [@butlerIntegratingSinglecellTranscriptomic2018]. 

## Normalization and batch effect correction

We tested several gene count normalization approaches as we were not certain which would produce an optimal outcome: standard (default Seurat, library size normalization, then log transform), sqrt (same, but with sqrt normalization), libSize (omit the log or sqrt normalization), scran, SCT from Seurat, and for scVI, no normalization (counts) [@lunStepbystepWorkflowLowlevel2016]. Our R implementation of the normalization approaches as well as how we constructed the Seurat v3 object can be found in the supplementary file "make_seurat_obj_functions.R"

## Batch normalization under a grid search procedure

We tested `r methods` against 2000 HVGs, the different gene count normalization procedures discussed above, and both 8 and 30 outputted batch corrected latent dimensions. The latent dimensions are the input for clustering, the 2D UMAP visualization, and the xgboost machine learning to transfer cell type labels to unlabelled cells. We were unable to run every method successfully with every normalization method. Magic could not complete with the standard or libSize normalization. CCA could not complete with the libSize normalization. We also tried the DESC, liger, and Conos batch corrections methods but were unable to get them to work reliably so they were dropped. The batch correction step implementation can be found the supplementary file "merge_methods.R".

## Clustering and UMAP
Louvain-Jaccard clustering against the batch corrected latent dimensions used the Seurat implementation [@blondelFastUnfoldingCommunities2008]. We tried the k-nearest neighbors (knn) parameters 5 and 7 (where 5 gives more clusters than 7). We also used the leiden algorithm as implemented by PARC with a resolution of 0.6 and 0.8 (higher results in more clusters) [@traagLouvainLeidenGuaranteeing2019; @stassenPARCUltrafastAccurate2020]. These two resolutions were chosen as they roughly gave the same number of clusters at the Seurat Louvain-Jaccard aprroach with a knn 7. 

The UMAP visualization was calculated with the Seurat "RunUMAP" using the uwot R package [@mcinnesUMAPUniformManifold2020]. We altered the min.dist parameter with 0.001 and 0.1 and tried n.neighbors across 15, 30, 100, and 500. A smaller min.dist value gives "tighter" groupings while a higher number of n.neighbors uses a larger number of near cells to calculate the global positioning. 

## Benchmarking 

We wrote the scPOP R package to unify the LISI and Silhouette metrics from Harmony and kBet, respectively, along with NMI and ARI [@buttnerTestMetricAssessing2019; @korsunskyFastSensitiveAccurate2019]. LISI and Silhouette require a dense matrix, which is a problem for our data as a 7e5 x 20,000 matrix cannot fit in a 1.5 TB memory node. We down-sampled the dataset to ~100,000 cells, taking care to keep all rarer cell types for the LISI and Silhouette benchmarking.

To merge these metrics into a balanced single score, we Z scale each and sum them. scPOP produces both tables and visualizations allowing the user to quickly see both the interplay of batch mixing and cluster/cell type separation and the overall performance. If a user wishes to prioritize batch mixing or cluster/cell type separation we let the user provide a custom batch/cluster-cell type scaling value (1 is the default). 

## Multi-step doublet removal
While we removed droplet-based cells with more than 3,000 transcripts as these are highly likely to be doublets (more than one cell per droplet) there were likely many more doublets. We ran DoubletDetect and scrublet and calculated the distribution of DoubletDetect and scrublet scores across all clusters and removed clusters with a score in both metrics greather than 4 standard deviations above the mean [@adamgayosoJonathanShorDoubletDetectionDoubletdetection2020; @wolockScrubletComputationalIdentification2019]. This removed another `r format((umapRef %>% nrow() %>% as.integer()) - (meta_filter %>% nrow() %>% as.integer()), big.mark=",", scientific=FALSE)` cells, leaving `r format((meta_filter %>% nrow()) %>% as.integer(), big.mark=",", scientific=FALSE)` in total. 

## xgboost based cell type model

In order to identify cell types for the `r format(meta_filter %>% filter(is.na(CellType), is.na(TabulaMurisCellType)) %>% nrow(), big.mark=",", scientific=FALSE)` unlabelledcells we designed a custom xgboost based cell type classifier. We took labeled data and split it into training and test sets, stratified by cell type. The input features used to train the model are the scVI latent dimensions, the total number of reads in each cell, the number genes detected in each cell, and the percent mitochondrial gene expression of each cell. We additionally generated features using the age of each sample by group sample into three developmental categories (Early Development, Late Development, and Adult) and then generated a one-hot encoded feature for each category. In order to speed up training times, we used the gpu implementation of the xgboost algorithm from the the xgboost python library. The model was trained using default parameters. The trained model had an overall F1 score of XXX an average precision and recall of XXX and XXX for each major retinal cell type. This model was then used to identify labels for each unlabelled cell. Unlabelled data was preprocessed identically to training data and fed into model to generate a vector of label probabilities for each cell. We selected the highest label probability for each cell, and required a minimum probability of .5 to assign a label to a cell. 

<!-- ## pseudobulk differential expression testing -->

<!-- Our pseudo-bulk differential testing was inspired by the OSCA guide. We computed differential tests for: cell type (published/transferred) against remaining cell types, celltype (published/transferred) pairwise against other individual celltype (published/transferred), specific cluster against remaining clusters, specific cluster against different individual cluster (pair-wise). Briefly, we grouped cells by the categories (e.g. each unique celltype (transferred) - study combination) and summed all gene counts. After summing the scores, we built a model matrix as 0 ~ categories + organism to remove any species specific effects. When then used the edgeR "estimateDisp" and tested the fit with "glmQLFit" and the parameter "robust = TRUE". Specific contrasts (e.g. Rods vs Cones) were differentially tested with "glmQLFTest". -->

## Marker gene identification

To identify marker genes across the CellType (predict) and cluster groups, we used the scran findmarkers (wilcox test) along with the singleCellHaystack algorithm. The scran findmarkers test runs a wilcox test in a pairwise manner (e.g. Rods vs all other cell types). It returns an overall p-value (and FDR) that assesses how well the gene is at separating the group of interest from all other cells. It also returns for each pair-wise comparison an area under the curve (AUC) score, where 1 is a perfect power to distinguish and 0 is no power. The singleCellHaystack uses a Kullback-Leibler divergence measurement of the scVI lower dimensional space to identify genes with non-random distribution. A higher "D KL" score represents a gene with "specific" expression in teh UMAP/lower dimensional space. We filtered to keep genes with FDR < 0.01 and a mean AUC > 0.2 or  a D KL > 0.2. 

<!-- ## Trajectory -->

<!-- To calculate continuous trajectories for individual terminally differentiated retina cell types, we used the Slingshot R package [@streetSlingshotCellLineage2018] on the human subset. Slingshot first uses the clusters to build a minimum spanning tree to identify the global lineage structure. We specified the starting cluster by identifying the cluster for human and mouse with a high proportion of the early RPC cells and specified the end clusters that were predominantly a terminal retina cell type (Amacrine, (Rod) Bipolar, Cones, Horizontal, Muller Glia, Retinal Ganglion, Rods). As some clusters were combinations of different (but similar) cell types, we "subclustered" the clusters by splitting them into smaller groups if they contained two or more cell types with > 20% ratio of a cell type. XXXX trajectories were built and we hand-pruned out redundant or non-sensical (e.g. Photoreceptor precursors to Cone to Rod Bipolar) trajectories, leaving XXXX trajectories for downstream analysis.  -->

<!-- To identify major points of gene expression changes during differentiation we built linear models across XXXXXXX bins.  -->

<!-- ## velocity -->

<!-- To id -->

# Conclusion

# Limitations   

The scVI model is first built the on human data. The mouse and macaque data are then projected (or queried) onto it with the scVI/scArches approach. While this system works very well to integrate information between these three species, this approach may not scale to more distantly related species. Another limitations is that discrepancies between cell type labels between different labs makes certain transitioning cell type labels a bit imprecise. One example is how the rods and photoreceptor precursor labels overlap somewhat. Though we attempted to ameliorate the issue by removing cell type labels in large disagreement with the consensus our cell type labels are effectively "crowd-sourced" and some disagreements can propagate into our labeled cells. 

## The scEiaD is a unique ocular resource that provides a highly diverse, large N dataset with a relatively small amount of compute power

We have assembled the largest ocular single cell transcriptome database to date. The rapid of advancement of algorithms to batch correct and process data continue to reduce the computational requirements to handle huge numbers of cells. The scVI batch correction step on around one million cells runs within a few hours on a GPU and 150GB of memory. This places this crucial step within the capabilities of a moderately large physical server or a cloud compute node. Further downstream proessing can largely be done a computers with 64+ Gb of memory and a few hundred GB of disk space. We believe that our efforts can be replicated in any other tissue / system with a large number of independent studies by an individual lab or small number of scientists. We provide the completed analysis as both Scanpy (h5ad) and Seurat objects at https://github.com/davemcg/scEiaD. 

## Benchmarking and quantitation of integration performance is crucial for meta-atlas studies

We originally intended to just use the Seurat CCA method to integrate the datasets. However, the long run-times of CCA and poor integration of our known cell types led us to benchmark more methods and parameters. We also originally attempted to "hand-assess" the integration results by using the UMAP 2D projection view. This proved to scale poorly and this led use to curate some of the most useful benchmarking algorithms (NMI, ARI, silhouette, and LISI) that roughly matched our "hand-assessed" results into the scPOP R package. While we chose the scVI algorithm, we do not believe that it will work best for all datasets. We strongly suggest any other groups attempting a similar meta-atlas construction chose a quantifiable set of criteria so optimal methods and parameters can be picked. 

## Transfer of cell type labels from a smaller number of studies onto the remainining cells is a powerful way to increase diversity in a meta-atlas

We hand curate over 300,000 cell type labels. With a standard xgboost algorithm using the latent dimensions, cell age classification (developing or matured), and the UMAP coordinates, we can very accurately label the remaining cells. Many other cell type labelling algorithms and systems exist for those groups less willing or able to tune a machine learning algorithm. For example, the developers of scVI also have a cell type label projection algorithm called scANVI. Whichever approach you use, taking a smaller number of high quality labels and projecting them onto the remaining cells is a powerful way to leverage community knowledge across a huge diverse dataset. 

## Projection allows community knowledge to be leveraged by all

Many retina "atlases" have been published to date. We argue that we have created the first atlas that is generally useful because 1. our dataset/atlas is several times larger than any other published set, 2. our data is available via download in several forms at https://github.com/davemcg/scEiaD, and crucially 3. we provide a Google colab/Jupyter notebook which exactly lays out how to use scVI's to project (or query) outside data onto our scEiaD with minimum compute resources. Finally we also provide our xgboost model so outside groups can label their own datasets with our robust retina cell type labelling system. 

# Supplemental
```{r supFig1, fig.width=4, fig.height=6, out.width=300, fig.cap=supFig1_cap, echo=FALSE, message = FALSE}
supFig1_cap <- supFig_cap(name='supFig1_cap', caption =  'The left bar delineates the number of cells for each organism - technology combination. The right bar specifies the number of each cells in each post QC category. In silico doublets were identified with scrublet and DoubletDetector.')

source('figs_and_tables/sup_fig1__qc_failure.R')
supFig1_plot
```


Words

Spacing



```{r supFig_benchmark, fig.width=12, fig.height=8, out.width=300, fig.cap=supFig_benchmark_cap, echo=FALSE, message = FALSE}
supFig_benchmark_cap <- supFig_cap(name='supFig_benchmark', caption =  'Performance of the various batch correction tools across various benchmarking metrics. For the LISI and Silhouette plots in A, B higher means better batch mixing and further to the right means better cluster purity. For the ARI and NMI metrics (which reflects how well cluster matches with cell type) in C, D, higher means a better score.')

source('figs_and_tables/fig2__integrationPerf.R')
cowplot::plot_grid(
  cowplot::plot_grid(lisi + theme(legend.position="none"), silhouette, NULL, rel_widths = c(1,1,0.2), nrow = 1, labels = c('a' ,'b')), 
  cowplot::plot_grid(ari, nmi, legend, rel_widths = c(1,1, 1, 0.2), ncol = 4, labels = c('c', 'd')), 
  nrow = 2)
```

Words

Spacing


```{r supTab1_CTcounts, fig.width=8, fig.height=14, out.width=300, fig.cap=supTab1_CTcounts_cap, echo=FALSE, message = FALSE}
supTab1_CTcounts_cap <- supTab_cap(name='supTab1_CTcounts_cap', caption =  'Counts for cell type labels. Published are the author created labels from the published datasets. Transferred area the cell labels that were transferred by a machine learning model onto the entire scEiaD dataset.')

source('figs_and_tables/sup_fig2__celltype_xgboost_labelling.R')
fontsize(ctTable, size = 8, part = 'all')
```



Words

Spacing



```{r supTab_SAcounts, fig.width=8, fig.height=14, out.width=300, fig.cap=supTab_SAcounts_cap, echo=FALSE, message = FALSE}
supTab_SAcounts_cap <- supTab_cap(name='supTab_SAcounts_cap', caption =  'Counts for number of studies with cell types labels before and after cell type label transfer')

source('figs_and_tables/sup_fig2__celltype_xgboost_labelling.R')
fontsize(saTable, size = 8, part = 'all')
```


Words

Spacing



```{r supFig_PR, fig.width=12, fig.height=10,  fig.cap=supFig_PR_cap, echo=FALSE, message = FALSE}
supFig_PR_cap <- supFig_cap(name='supFig_PR', caption =  'Precision recall curves for our xgboost cell type predictor model across each cell type predicted')

source('figs_and_tables/sup_fig__xgboost_PR.R')
pr_split_curves
```


Words

Spacing



```{r supTab_AUCxgboost, fig.cap=supTab_AUCxgboost_cap, echo=FALSE, message = FALSE}
supTab_AUCxgboost_cap <- supTab_cap(name='supTab_AUCxgboost', caption =  'Area under the precision recall curve (AUC) for each cell type, split by study')

#source('figs_and_tables/sup_fig2__celltype_xgboost_labelling.R')
fontsize(xgboost_pr_table_full %>% arrange(`Cell Type`, Study) %>% flextable() %>% width(width = 3), size = 8, part = 'all')
```


Words

Spacing




```{r supTab_CTmislabels, fig.width=2, fig.cap=supTab_CTmislabels_cap, echo=FALSE, message = FALSE}

supTab_CTmislabels_cap <- supTab_cap(name='supTab_CTmislabels', caption =  'TEXT2')

#source('figs_and_tables/sup_fig2__celltype_xgboost_labelling.R')
fontsize(predictions %>%  
           mutate(max_pred_prob = rowMaxs(.[,-(31:ncol(predictions))] %>% as.matrix )) %>% 
           select(-cell_type_id) %>% 
           rename(PredCellType = CellType) %>% 
           inner_join(umapRef %>% select(Barcode, TrueCellType = CellType)) %>% 
           filter(!is.na(TrueCellType)) %>% 
           mutate(pred_correct  = ifelse(PredCellType == TrueCellType, 'Correct', 'incorrect')) %>% 
           group_by(PredCellType, TrueCellType) %>% 
           summarise(Count = n()) %>% 
           mutate(Ratio  = round(Count / sum(Count),2 )) %>% 
           filter(Ratio > 0.05) %>% 
           filter(!grepl('Doubl|Periocu', TrueCellType)) %>% 
           flextable() %>% 
           autofit(), 
         size = 8, 
         part = 'all')
```



Words

Spacing


```{r supFig_platformInt, fig.width=12, fig.height=10,  fig.cap=supFig_platformInt_cap, echo=FALSE, message = FALSE}
supFig_platformInt_cap <- supFig_cap(name='supFig_platformInt', caption =  '')
input <- list()
input[['meta_column']] <- 'CellType_predict'
input[['pt_size_back']] <- 5
input[['pt_size_meta']] <- 5
input[['gene_and_meta_scatter_tech']] <- 'Droplet'
input[['meta_column_transform']] <- 'None'
#input[['meta_filter_cat']] <- 'CellType_predict'
#input[['meta_filter_on']] <- 'Bipolar Cells'
ctp3 <- make_meta_scatter_umap_plot(input, mf, meta_filter,
                                    celltype_predict_labels,
                                    celltype_labels,
                                    tabulamuris_predict_labels,
                                    cluster_labels,
                                    cat_to_color_df
)


ctp3$plot + facet_wrap(~Platform)
```


```{r projection_fig, fig.width=12, fig.height=10,  fig.cap=projection_fig_cap, echo=FALSE, message = FALSE}
projection_fig_cap <- supFig_cap(name='projection_fig', caption =  '')
input[['pt_size_back']] <- 0
input[['pt_size_meta']] <- 6
input[['meta_column']] <- 'study_accession'
#input[['gene_and_meta_scatter_tech']] <- 'Droplet'
input[['meta_column_transform']] <- 'None'
input[['meta_filter_cat']] <- 'CellType_predict'
input[['meta_filter_on']] <- c('RPE')
rpe <- make_meta_scatter_umap_plot(input, mf, meta_filter,
                                   celltype_predict_labels,
                                   celltype_labels,
                                   tabulamuris_predict_labels,
                                   cluster_labels,
                                   cat_to_color_df
)
#

colab_p <- ggdraw() + draw_image("figs_and_tables/colab_screenshot.png", scale = 0.7)

plot_grid(rpe$plot , colab_p)



```


